# 轨迹规划与速度控制模块架构设计方案

## 1. 项目背景与需求

### 1.1 当前代码现状
经过对 `trajectory_plan`、`ladrc`（已提取TD）、`chassis_calculations` 三个模块的详细分析，发现以下问题：

- **代码冗余**：chassis_calculations 模块包含约 250 行死代码（`#if 0` 块）
- **功能未实现**：S型速度规划仅定义接口，内部是TODO占位符
- **架构混乱**：全局变量滥用，命名混乱，场景混合

### 1.2 使用场景需求

| 场景类型 | 核心需求 | 约束特点 | 典型算法 |
|---------|---------|---------|---------|
| **机械臂关节规划** | 各关节独立运动 | 关节位置/速度/加速度限制 | 梯形/S曲线插补 |
| **机械臂笛卡尔规划** | 末端位姿平滑 | 笛卡尔速度/加速度限制 | 冗余度解析、阻尼最小二乘 |
| **底盘速度向量限制** | 速度幅值约束（防侧翻） | 速度向量模长限制 | 速度幅值限制、向量归一化、余弦平滑 |

### 1.3 关键约束差异

**机械臂场景**：
- 关心每个关节的运动学限制
- 需要反向运动学计算
- 末端位姿精度要求高

**底盘场景**：
- 关心速度向量的幅值（`speed_point_limit` 防侧翻）
- 需要实时平滑（从A点到B点，保持`last_point`记忆）
- 快速响应，避免机械冲击

---

## 2. 三种架构方案详细设计

---

### 方案一：分层模块化

#### 2.1 架构图示

```
┌─────────────────────────────────────────────────────────────┐
│                    Trajectory_Plan_API                       │
│        init() / update() / get_state() / reset()             │
└───────────────────────────┬─────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│  JointPlan    │   │ CartesianPlan │   │  ChassisPlan  │
│ (机械臂关节)   │   │ (机械臂笛卡尔) │   │   (底盘)      │
├───────────────┤   ├───────────────┤   ├───────────────┤
│ 梯形/S曲线插补  │   │  速度投影+逆解 │   │ 速度向量限幅   │
│ 关节独立限幅    │   │  笛卡尔速度限制 │   │ 防侧翻约束    │
└───────────────┘   └───────────────┘   └───────────────┘
                ┌───────────────────┐
                ▼                   ▼
        ┌───────────────┐   ┌───────────────┐
        │  通用插补库   │   │   约束检查库   │
        │ • 梯形        │   │ • 位置限幅    │
        │ • S曲线       │   │ • 速度限幅    │
        │ • 余弦        │   │ • 加速度限幅  │
        └───────────────┘   └───────────────┘
```

#### 2.2 文件结构

```
trajectory_plan/
├── trajectory_base.h          # 通用API接口定义
│   ├── PlannerState 结构体
│   ├── PlannerType 枚举
│   ├── PlannerConfig 配置
│   └── 虚函数接口声明
├── trajectory_base.c          # 基础逻辑（可复用代码）
├── trajectory_joint.h/c       # 关节空间规划实现
├── trajectory_cartesian.h/c   # 笛卡尔空间规划实现
└── trajectory_chassis.h/c     # 底盘专用规划
    └── 包含 speed_point_limit 逻辑

utils/
├── interpolation.h/c          # 插补算法库
│   ├── trapezoid_interp()     # 梯形插补
│   ├── scurve_interp()        # S曲线插补
│   └── cosine_interp()        # 余弦平滑
└── constraint.h/c             # 约束检查工具
    ├── check_joint_limit()
    └── check_speed_vector()
```

#### 2.3 代码示例

```c
// trajectory_base.h

typedef enum {
    PLANNER_TRAPEZOID,   // 梯形规划
    PLANNER_SCURVE,      // S曲线规划
    PLANNER_COSINE,      // 余弦规划
} InterpolationType;

typedef struct {
    float p_start;
    float p_goal;
    float v_max;
    float a_max;
    float dt;
} PlannerConfig;

typedef struct {
    float current_p;     // 当前位置
    float current_v;     // 当前速度
    float current_a;     // 当前加速度
    int   finished;      // 是否完成
} PlannerState;

// 虚接口
void planner_init(void* instance, PlannerConfig* cfg);
int  planner_update(void* instance, float target, float measure, PlannerState* out);
void planner_reset(void* instance, float init_val);

// trajectory_chassis.h
// 底盘特有配置
typedef struct {
    PlannerConfig base;
    
    // 底盘特有
    float last_vx;       // 上周期X速度
    float last_vy;       // 上周期Y速度
    float speed_limit;   // 速度限制阈值
    float base_limit;    // 基础速度限制
    float max_limit;     // 最大速度限制
} ChassisConfig;

// 底盘特有状态
typedef struct {
    PlannerState vx_state;
    PlannerState vy_state;
    PlannerState vw_state;
} ChassisState;

void chassis_planner_init(ChassisConfig* cfg);
void chassis_planner_update(float target_vx, float target_vy, float target_vw,
                           ChassisState* state);
```

#### 2.4 优缺点分析

**优点**：
- ✅ **职责分离**：每个模块只负责自己的场景
- ✅ **易于扩展**：增加云台/腿足等新场景只需添加新模块
- ✅ **代码复用**：插补算法在底层统一实现
- ✅ **调试方便**：底盘和机械臂问题独立排查

**缺点**：
- ⚠️ **代码量中等**：比完全独立方案多一些接口代码
- ⚠️ **需要学习成本**：需要理解分层架构

---

### 方案二：策略模式 + 回调注册

#### 2.1 架构图示

```
┌─────────────────────────────────────────────────────────────┐
│              TrajectoryPlanner（统一入口）                    │
│  ┌─────────────────────────────────────────────────────┐  │
│  │  配置结构体:                                          │  │
│  │    - interpolation_type: TRAPEZOID/SCURVE/COSINE     │  │
│  │    - constraint_type: JOINT_LIMIT / CARTESIAN_LIMIT  │  │
│  │                        / CHASSIS_SPEED_LIMIT         │  │
│  │    - constraint_fn: 用户自定义约束回调                │  │
│  └─────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ 插补策略      │   │ 约束策略      │   │ 回调函数      │
├───────────────┤   ├───────────────┤   ├───────────────┤
│ • 梯形        │   │ • 关节限幅    │   │ 用户自定义    │
│ • S曲线       │   │ • 笛卡尔限幅  │   │               │
│ • 余弦        │   │ • 底盘限幅    │   │               │
└───────────────┘   └───────────────┘   └───────────────┘
```

#### 2.2 文件结构

```
trajectory_plan/
├── trajectory_planner.h/c     # 核心规划器（策略控制器）
├── trajectory_config.h        # 统一配置
├── strategy/
│   ├── interpolation.h/c      # 插补策略
│   │   ├── strategy_trapezoid()
│   │   ├── strategy_scurve()
│   │   └── strategy_cosine()
│   └── constraint.h/c         # 约束策略
│       ├── constraint_joint()
│       ├── constraint_cartesian()
│       └── constraint_chassis()  // 包含防侧翻逻辑
└── callback.h                 # 回调定义

// 使用示例
PlannerConfig cfg = {
    .interp_type = PLANNER_COSINE,
    .constraint_type = CONSTRAINT_CHASSIS,
    .custom_constraint = my_extra_constraint,
};
planner_init(&planner, &cfg);
```

#### 2.3 代码示例

```c
// trajectory_planner.h

typedef enum {
    INTERP_TRAPEZOID,
    INTERP_SCURVE,
    INTERP_COSINE,
} InterpolationStrategy;

typedef enum {
    CONSTRAINT_NONE,
    CONSTRAINT_JOINT,      // 机械臂关节约束
    CONSTRAINT_CARTESIAN,  // 笛卡尔空间约束
    CONSTRAINT_CHASSIS,    // 底盘速度向量约束
} ConstraintStrategy;

// 约束回调签名
typedef void (*ConstraintCallback)(float* target_vx, float* target_vy,
                                   float* target_vw, void* user_data);

typedef struct {
    InterpolationStrategy interp_type;
    ConstraintStrategy constraint_type;
    ConstraintCallback custom_constraint;  // 可选
    void* user_data;
    
    // 物理参数
    float max_accel;
    float max_decel;
    float dt;
} PlannerConfig;

typedef struct {
    PlannerConfig cfg;
    
    // 状态
    float current_speed;
    float current_accel;
    
    // 插补状态（根据策略不同而不同）
    void* interp_state;
} TrajectoryPlanner;

void planner_init(TrajectoryPlanner* planner, PlannerConfig* cfg);
int planner_update(TrajectoryPlanner* planner,
                  float target, float measure,
                  float* output_speed);

// 约束策略实现示例
void constraint_chassis(float* vx, float* vy, float* vw, void* data) {
    ChassisConstraintData* d = (ChassisConstraintData*)data;
    
    // 计算速度变化量
    float dx = *vx - d->last_vx;
    float dy = *vy - d->last_vy;
    float distance = sqrt(dx*dx + dy*dy);
    
    // 根据梯形函数计算速度限制
    float limit;
    if (distance <= d->threshold) {
        limit = d->threshold;
    } else if (distance <= d->threshold + (d->max_limit - d->base_limit) * 2.0f) {
        limit = d->base_limit + (distance - d->threshold) / 2.0f;
    } else {
        limit = d->max_limit;
    }
    
    // 限幅
    if (distance > limit) {
        float ratio = limit / distance;
        *vx = d->last_vx + dx * ratio;
        *vy = d->last_vy + dy * ratio;
    }
    
    // 更新历史
    d->last_vx = *vx;
    d->last_vy = *vy;
}
```

#### 2.4 优缺点分析

**优点**：
- ✅ **灵活性最高**：可随时切换插补和约束策略
- ✅ **配置驱动**：通过配置表即可改变行为
- ✅ **扩展性强**：新增策略只需注册新函数
- ✅ **适合通用库**：可作为战队通用底层库

**缺点**：
- ⚠️ **实现复杂度高**：需要理解策略模式和回调机制
- ⚠️ **运行时开销**：函数指针调用有微小开销
- ⚠️ **调试困难**：策略动态组合时问题定位难
- ⚠️ **学习曲线陡峭**：对新成员不友好

---

### 方案三：完全独立模块（最简单）

#### 2.1 架构图示

```
┌─────────────────────────────────────────────────────────────┐
│                      完全独立，零耦合                        │
└─────────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ joint_planner │   │cartesian_planner│  │chassis_limiter│
│  (机械臂关节)  │   │ (机械臂笛卡尔)  │   │   (底盘)      │
├───────────────┤   ├───────────────┤   ├───────────────┤
│ 梯形规划      │   │ 位姿规划      │   │ 速度向量限幅   │
│ 关节限幅      │   │ 逆运动学      │   │ 防侧翻检查    │
└───────────────┘   └───────────────┘   └───────────────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            ▼
                  ┌───────────────┐
                  │  td/ (TD模块) │  // 仅引用TD
                  │  微分平滑     │
                  └───────────────┘
```

#### 2.2 文件结构

```
modules/
├── joint_planner/
│   ├── joint_planner.h/c      # 机械臂关节规划
│   └── 完全独立实现
├── cartesian_planner/
│   ├── cartesian_planner.h/c  # 笛卡尔规划
│   └── 完全独立实现
├── chassis_planner/
│   ├── chassis_planner.h/c    # 底盘规划
│   └── speed_point_limit 实现
└── common/
    ├── interpolation.h/c      # 可选：公共插补（如果不复用可删除）
    └── math_utils.h/c         # 可选：数学工具

td/                          # TD模块（独立）
├── td.h
└── td.c
```

#### 2.3 代码示例

```c
// joint_planner.h - 机械臂关节专用
#ifndef JOINT_PLANNER_H
#define JOINT_PLANNER_H

typedef struct {
    float q_start[6];     // 起始关节角度
    float q_goal[6];      // 目标关节角度
    float v_max[6];       // 各关节最大速度
    float a_max[6];       // 各关节最大加速度
    float dt;             // 控制周期
} JointPlanConfig;

typedef struct {
    float q_current[6];
    float v_current[6];
    int finished;
} JointPlanState;

void joint_planner_init(JointPlanConfig* cfg);
int joint_planner_update(float target[6], JointPlanState* state);

#endif

// chassis_planner.h - 底盘专用
#ifndef CHASSIS_PLANNER_H
#define CHASSIS_PLANNER_H

typedef struct {
    float max_accel_x;    // X方向最大加速度
    float max_accel_y;    // Y方向最大加速度
    float max_accel_w;    // 旋转最大角加速度
    float dt;             // 控制周期
    
    // 速度向量限制参数
    float base_limit;     // 基础速度限制
    float max_limit;      // 最大速度限制
    float threshold;      // 阈值速度
} ChassisPlanConfig;

typedef struct {
    float vx;             // 当前X速度
    float vy;             // 当前Y速度
    float vw;             // 当前角速度
    float last_vx;        // 上周期X速度
    float last_vy;        // 上周期Y速度
} ChassisPlanState;

void chassis_planner_init(ChassisPlanConfig* cfg);
void chassis_planner_update(float target_vx, float target_vy, float target_vw,
                           ChassisPlanState* state);

// 余弦平滑算法
void cosine_smooth(float diff, float max_change, float* current, float target);

// 速度向量限制（防侧翻核心）
void speed_point_limit(float* vx, float* vy, 
                       float last_vx, float last_vy,
                       float base_limit, float max_limit, float threshold);

#endif
```

#### 2.4 优缺点分析

**优点**：
- ✅ **实现最简单**：直接复制现有代码即可
- ✅ **零学习成本**：看到文件名就知道功能
- ✅ **调试方便**：问题就在对应模块里
- ✅ **无耦合风险**：修改一个不影响其他

**缺点**：
- ❌ **代码重复**：插补算法要写三份（如果有差异）
- ❌ **维护困难**：修复一个bug要在多处修改
- ❌ **无抽象层次**：难以看出架构设计
- ❌ **难以扩展**：增加新场景=增加新文件

---

### 方案四：枚举驱动配置方案（改进的回调注册）

#### 4.1 设计理念

结合方案二的**预定义策略**和方案三的**调用简洁性**，改进 `chassis_calculations.c` 的**全局变量**设计，采用**实例化+枚举配置**模式。

**核心改进**：
- ❌ 去除全局变量（`chassis_speed_plan_type`）
- ✅ 每个规划器独立实例（支持多底盘、多机械臂）
- ✅ 预定义策略组合（不需要用户写回调）
- ✅ 初始化时配置一次，运行时自动分发

#### 4.2 架构图示

```
┌─────────────────────────────────────────────────────────────┐
│                    UnifiedPlanner（统一入口）                 │
│  ┌─────────────────────────────────────────────────────┐  │
│  │  配置结构体:                                          │  │
│  │    - instance_type: CHASSIS / JOINT / CARTESIAN     │  │
│  │    - interp_type: TRAPEZOID / COSINE / SCURVE       │  │
│  │    - constraint_type: SPEED_LIMIT / JOINT_LIMIT     │  │
│  └─────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
                    ┌───────────────┐
                    │  策略分发器   │
                    │  (switch-case)│
                    └───────┬───────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│  插补算法     │   │  约束检查     │   │  具体场景     │
├───────────────┤   ├───────────────┤   ├───────────────┤
│ • 梯形        │   │ • 速度向量限幅 │   │ • 底盘        │
│ • 余弦        │   │ • 关节限幅    │   │ • 机械臂      │
│ • S曲线       │   │ • 加速度限幅  │   │ • 笛卡尔      │
└───────────────┘   └───────────────┘   └───────────────┘
```

#### 4.3 文件结构

```
trajectory_plan/
├── unified_planner.h/c          # 统一规划器入口
│   ├── UnifiedPlanner 结构体
│   ├── PlannerConfig 配置结构体
│   └── planner_init() / planner_update()
├── config/
│   ├── planner_types.h          # 枚举定义
│   │   ├── InstanceType 枚举
│   │   ├── InterpType 枚举
│   │   └── ConstraintType 枚举
│   └── preset_configs.h         # 预定义配置模板
├── core/
│   ├── interpolation.c          # 插补算法库
│   │   ├── interp_trapezoid()
│   │   ├── interp_cosine()
│   │   └── interp_scurve()
│   └── constraint.c             # 约束检查库
│       ├── constraint_speed_vector()
│       └── constraint_joint_limit()
└── adapters/
    ├── chassis_adapter.c        # 底盘适配器
    ├── joint_adapter.c          # 关节适配器
    └── cartesian_adapter.c      # 笛卡尔适配器

td/
├── td.h/c                       # TD模块（独立）
```

#### 4.4 代码示例

```c
// planner_types.h - 枚举定义
#ifndef PLANNER_TYPES_H
#define PLANNER_TYPES_H

typedef enum {
    INSTANCE_CHASSIS,      // 底盘实例
    INSTANCE_JOINT,        // 机械臂关节
    INSTANCE_CARTESIAN,    // 笛卡尔空间
} InstanceType;

typedef enum {
    INTERP_TRAPEZOID,      // 梯形插补
    INTERP_COSINE,         // 余弦平滑
    INTERP_SCURVE,         // S曲线
} InterpType;

typedef enum {
    CONSTRAINT_NONE,
    CONSTRAINT_SPEED_VECTOR,   // 速度向量限幅（底盘）
    CONSTRAINT_JOINT_LIMIT,    // 关节限幅（机械臂）
    CONSTRAINT_CARTESIAN_VEL,  // 笛卡尔速度限幅
} ConstraintType;

#endif

// unified_planner.h - 统一规划器
#ifndef UNIFIED_PLANNER_H
#define UNIFIED_PLANNER_H

#include "config/planner_types.h"

// 通用物理参数（所有场景共享）
typedef struct {
    float dt;              // 控制周期
    float v_max;           // 最大速度
    float a_max;           // 最大加速度
    float j_max;           // 最大加加速度（可选）
} PhysicsParams;

// 底盘专用参数
typedef struct {
    float max_vx;          // X方向最大速度
    float max_vy;          // Y方向最大速度
    float max_vw;          // 旋转最大速度
    float accel_x;         // X加速度
    float accel_y;         // Y加速度
    float accel_w;         // 角加速度
    float speed_base;      // 速度限制基础值
    float speed_max;       // 速度限制最大值
    float speed_threshold; // 速度限制阈值
} ChassisParams;

// 机械臂专用参数
typedef struct {
    int dof;               // 自由度数量
    float q_max[6];        // 各关节最大角度
    float q_min[6];        // 各关节最小角度
    float v_max[6];        // 各关节最大速度
    float a_max[6];        // 各关节最大加速度
} JointParams;

// 笛卡尔专用参数
typedef struct {
    float v_max[6];        // 笛卡尔空间最大速度 [vx, vy, vz, wx, wy, wz]
    float a_max[6];        // 笛卡尔空间最大加速度
} CartesianParams;

// 统一配置结构体
typedef struct {
    InstanceType instance_type;
    InterpType interp_type;
    ConstraintType constraint_type;
    
    PhysicsParams physics;
    
    union {
        ChassisParams chassis;
        JointParams joint;
        CartesianParams cartesian;
    } specific;
    
    bool use_td;           // 是否使用TD
    float td_r;            // TD快速因子
    float td_n;            // TD滤波因子
} PlannerConfig;

// 状态结构体（场景无关）
typedef struct {
    float current_p;       // 当前位置
    float current_v;       // 当前速度
    float current_a;       // 当前加速度
    bool finished;         // 是否完成
    
    // 场景特有状态
    void* instance_state;  // 指向 ChassisState / JointState / CartesianState
} PlannerState;

// 规划器实例
typedef struct {
    PlannerConfig cfg;
    PlannerState state;
    void* private_data;    // 私有数据（插补状态、TD实例等）
} UnifiedPlanner;

// API
void planner_init(UnifiedPlanner* planner, const PlannerConfig* cfg);
int planner_update(UnifiedPlanner* planner, 
                  const float* target,
                  const float* measure,
                  float* output);
void planner_reset(UnifiedPlanner* planner, const float* init_val);
bool planner_is_finished(const UnifiedPlanner* planner);

// 预定义配置模板（快速初始化）
const PlannerConfig* planner_get_preset_chassis_cosine(void);
const PlannerConfig* planner_get_preset_chassis_trapezoid(void);
const PlannerConfig* planner_get_preset_joint_scurve(void);

#endif

// unified_planner.c - 核心实现（分发器）
#include "unified_planner.h"
#include "core/interpolation.h"
#include "core/constraint.h"
#include "adapters/chassis_adapter.h"
#include "adapters/joint_adapter.h"

void planner_init(UnifiedPlanner* planner, const PlannerConfig* cfg) {
    planner->cfg = *cfg;
    memset(&planner->state, 0, sizeof(PlannerState));
    
    // 根据实例类型初始化私有数据
    switch (cfg->instance_type) {
        case INSTANCE_CHASSIS:
            planner->private_data = chassis_adapter_init(&cfg->specific.chassis);
            break;
        case INSTANCE_JOINT:
            planner->private_data = joint_adapter_init(&cfg->specific.joint);
            break;
        case INSTANCE_CARTESIAN:
            // ...
            break;
    }
}

int planner_update(UnifiedPlanner* planner,
                  const float* target,
                  const float* measure,
                  float* output) {
    
    // 1. 应用插补算法
    float interp_output[6];
    switch (planner->cfg.interp_type) {
        case INTERP_TRAPEZOID:
            interp_trapezoid(planner, target, measure, interp_output);
            break;
        case INTERP_COSINE:
            interp_cosine(planner, target, measure, interp_output);
            break;
        case INTERP_SCURVE:
            interp_scurve(planner, target, measure, interp_output);
            break;
    }
    
    // 2. 应用约束检查
    switch (planner->cfg.constraint_type) {
        case CONSTRAINT_SPEED_VECTOR:
            if (planner->cfg.instance_type == INSTANCE_CHASSIS) {
                chassis_constraint_speed_vector(planner, interp_output);
            }
            break;
        case CONSTRAINT_JOINT_LIMIT:
            if (planner->cfg.instance_type == INSTANCE_JOINT) {
                joint_constraint_limit(planner, interp_output);
            }
            break;
        // ...
    }
    
    // 3. 场景特有处理
    switch (planner->cfg.instance_type) {
        case INSTANCE_CHASSIS:
            chassis_adapter_update(planner, interp_output, output);
            break;
        case INSTANCE_JOINT:
            joint_adapter_update(planner, interp_output, output);
            break;
    }
    
    return planner->state.finished ? 0 : 1;
}

// adapters/chassis_adapter.c - 底盘适配器
#include "chassis_adapter.h"

typedef struct {
    float last_vx;
    float last_vy;
    ChassisParams params;
} ChassisPrivateState;

void* chassis_adapter_init(const ChassisParams* params) {
    ChassisPrivateState* state = malloc(sizeof(ChassisPrivateState));
    state->last_vx = 0.0f;
    state->last_vy = 0.0f;
    state->params = *params;
    return state;
}

void chassis_constraint_speed_vector(UnifiedPlanner* planner, float* velocity) {
    ChassisPrivateState* state = (ChassisPrivateState*)planner->private_data;
    
    float vx = velocity[0];
    float vy = velocity[1];
    
    // 计算速度变化量（向量差）
    float dx = vx - state->last_vx;
    float dy = vy - state->last_vy;
    float distance = sqrt(dx*dx + dy*dy);
    
    // 根据梯形函数计算速度限制（防侧翻核心逻辑）
    float limit;
    ChassisParams* p = &state->params;
    
    if (distance <= p->speed_threshold) {
        limit = p->speed_threshold;
    } else if (distance <= p->speed_threshold + (p->speed_max - p->speed_base) * 2.0f) {
        limit = p->speed_base + (distance - p->speed_threshold) / 2.0f;
    } else {
        limit = p->speed_max;
    }
    
    // 应用限制
    if (distance > limit) {
        float ratio = limit / distance;
        velocity[0] = state->last_vx + dx * ratio;
        velocity[1] = state->last_vy + dy * ratio;
    }
    
    // 保存当前速度
    state->last_vx = velocity[0];
    state->last_vy = velocity[1];
}

void chassis_adapter_update(UnifiedPlanner* planner, 
                            const float* interp_output,
                            float* final_output) {
    // 底盘特有处理（如逆运动学、电机分配等）
    final_output[0] = interp_output[0];  // vx
    final_output[1] = interp_output[1];  // vy
    final_output[2] = interp_output[2];  // vw
}

// 使用示例（底盘场景）
void example_chassis_usage(void) {
    UnifiedPlanner chassis_planner;
    
    // 方式1：手动配置
    PlannerConfig cfg = {
        .instance_type = INSTANCE_CHASSIS,
        .interp_type = INTERP_COSINE,         // 使用余弦平滑
        .constraint_type = CONSTRAINT_SPEED_VECTOR,  // 速度向量限幅
        .physics = {
            .dt = 0.001f,
            .v_max = 40.0f,
            .a_max = 20.0f,
        },
        .specific.chassis = {
            .max_vx = 30.0f,
            .max_vy = 30.0f,
            .accel_x = 40.0f,
            .accel_y = 40.0f,
            .speed_base = 30.0f,
            .speed_max = 40.0f,
            .speed_threshold = 30.0f,
        },
        .use_td = true,
        .td_r = 2000.0f,
        .td_n = 3.0f,
    };
    planner_init(&chassis_planner, &cfg);
    
    // 方式2：使用预定义模板（更简单）
    // planner_init(&chassis_planner, planner_get_preset_chassis_cosine());
    
    // 运行时调用
    float target[3] = {20.0f, 15.0f, 0.5f};  // 目标速度
    float measure[3] = {0.0f};                // 当前测量值
    float output[3] = {0.0f};                 // 输出
    
    while (!planner_is_finished(&chassis_planner)) {
        planner_update(&chassis_planner, target, measure, output);
        // output[0] = vx, output[1] = vy, output[2] = vw
        HAL_Delay(1);
    }
}

// 使用示例（机械臂关节场景）
void example_joint_usage(void) {
    UnifiedPlanner joint_planner;
    
    PlannerConfig cfg = {
        .instance_type = INSTANCE_JOINT,
        .interp_type = INTERP_SCURVE,
        .constraint_type = CONSTRAINT_JOINT_LIMIT,
        .physics = {
            .dt = 0.001f,
            .v_max = 3.14f,   // rad/s
            .a_max = 10.0f,   // rad/s^2
        },
        .specific.joint = {
            .dof = 6,
            .q_max = {3.14f, 2.0f, 2.5f, 3.14f, 2.0f, 3.14f},
            .q_min = {-3.14f, -2.0f, -2.5f, -3.14f, -2.0f, -3.14f},
            .v_max = {3.0f, 3.0f, 3.0f, 4.0f, 4.0f, 6.0f},
        },
    };
    planner_init(&joint_planner, &cfg);
    
    float target[6] = {1.0f, 0.5f, 0.3f, 0.0f, 0.0f, 0.0f};  // 目标关节角度
    float measure[6] = {0.0f};                                // 当前角度
    float output[6] = {0.0f};                                 // 输出角度
    
    while (!planner_is_finished(&joint_planner)) {
        planner_update(&joint_planner, target, measure, output);
        // output = 规划后的关节角度
    }
}
```

#### 4.5 与 `chassis_calculations.c` 的改进对比

| 问题 | chassis_calculations.c | 方案四（枚举驱动） |
|-----|----------------------|------------------|
| **全局变量** | ❌ `chassis_speed_plan_type` 全局 | ✅ 每个规划器独立实例 |
| **状态隔离** | ❌ 静态全局 `chassis_speed_handle` | ✅ 私有状态在 `private_data` 中 |
| **多实例** | ❌ 无法支持多底盘 | ✅ 多个 `UnifiedPlanner` 实例 |
| **策略切换** | ✅ 运行时切换（但需全局变量） | ✅ 初始化时配置，运行时无需修改 |
| **代码清晰度** | ❌ switch-case 分散在各函数 | ✅ 分发器集中管理 |
| **扩展性** | ❌ 增加场景需改多处 | ✅ 增加适配器即可 |

#### 4.6 优缺点分析

**优点**：
- ✅ **调用简单**：`planner_init()` + `planner_update()` 两行代码
- ✅ **无全局变量**：每个规划器独立，支持多实例
- ✅ **预定义策略**：不需要用户写回调函数，枚举选择即可
- ✅ **配置灵活**：通过枚举组合不同策略
- ✅ **与TD解耦**：TD独立模块，按需使用
- ✅ **易于调试**：分发逻辑清晰，问题定位快

**缺点**：
- ⚠️ **运行时无法切换策略**：策略在初始化时确定（但战队通常不需要运行时切换）
- ⚠️ **代码量中等**：比分层方案略多，比策略方案少
- ⚠️ **union内存**：使用union节省内存，但需要类型安全检查

**与回调注册方式的关键区别**：

| 特性 | 回调注册（方案二） | 枚举驱动（方案四） |
|-----|------------------|------------------|
| 用户代码 | 需要写回调函数 | 只需填枚举值 |
| 配置复杂度 | 高（函数指针+用户数据） | 低（枚举+数值） |
| 新成员友好度 | 低 | 高 |
| 运行时切换 | ✅ 支持 | ❌ 不支持（需重新init） |
| 性能 | 中（函数指针开销） | 高（直接调用） |
| 灵活性 | 极高 | 中 |

**结论**：枚举驱动在战队场景下是**最佳平衡点**——简单、高效、无全局变量，且不需要过度灵活。

---

## 3. 方案对比总表

| 维度 | 方案一（分层） | 方案二（策略） | 方案三（独立） | 方案四（枚举驱动） |
|-----|--------------|--------------|--------------|------------------|
| **实现复杂度** | 中 | 高 | 低 | **中** ⭐ |
| **代码复用性** | 高 | 极高 | 低 | 高 |
| **扩展性** | 好 | 极好 | 差 | 好 |
| **运行时性能** | 高 | 中（函数指针开销） | 高 | **高** ⭐ |
| **调试难度** | 中 | 高 | 低 | **低** ⭐ |
| **新成员友好度** | 中 | 低 | 高 | **高** ⭐ |
| **长期维护性** | 好 | 好 | 差 | **好** ⭐ |
| **调用简洁性** | 中 | 中 | 高 | **高** ⭐ |
| **多实例支持** | ✅ | ✅ | ❌ | **✅** ⭐ |
| **运行时策略切换** | ❌ | ✅ | ✅ | ❌（不需要） |

### 3.1 关键能力对比

| 能力 | 方案一 | 方案二 | 方案三 | 方案四 |
|-----|--------|--------|--------|--------|
| **机械臂关节规划** | ✅ 专用模块 | ✅ 策略配置 | ✅ 独立文件 | ✅ 适配器模式 |
| **机械臂笛卡尔规划** | ✅ 专用模块 | ✅ 策略配置 | ✅ 独立文件 | ✅ 适配器模式 |
| **底盘速度向量限制** | ✅ 专用模块 | ✅ 策略配置 | ✅ 独立文件 | **✅ 枚举配置** |
| **余弦速度曲线** | ✅ 通用插补 | ✅ 可插拔策略 | ✅ 独立实现 | **✅ 插补选项** |
| **运行时切换策略** | ❌ 需重新初始化 | ✅ 支持 | ❌ 不支持 | ❌ 不支持 |
| **自定义约束** | ⚠️ 需修改代码 | ✅ 回调注册 | ⚠️ 需修改代码 | ⚠️ 需添加枚举值 |
| **无需写回调函数** | ✅ | ❌ | ✅ | **✅ 最佳** |
| **底盘速度向量限制** | ✅ 专用模块 | ✅ 策略配置 | ✅ 独立文件 |
| **余弦速度曲线** | ✅ 通用插补 | ✅ 可插拔策略 | ✅ 独立实现 |
| **运行时切换策略** | ❌ 需重新初始化 | ✅ 支持 | ❌ 不支持 |
| **自定义约束** | ⚠️ 需修改代码 | ✅ 回调注册 | ⚠️ 需修改代码 |

---

## 4. 针对战队场景的深入分析

### 4.1 战队技术背景考量

**人员构成**：
- 每年人员流动大（学长毕业、学弟加入）
- 部分成员嵌入式经验有限
- 需要快速上手和调试

**开发周期**：
- 比赛周期紧张，没有太多时间重构
- 需要稳定可靠的基础代码
- 调试时间多于开发时间

**使用场景**：
- 机械臂和底盘通常不会同时大幅修改
- 插补算法相对固定（梯形为主，偶尔S曲线）
- 约束场景明确（不会出现奇怪的组合需求）

### 4.2 各方案在战队场景的表现

**方案一（分层）- 推荐** ⭐⭐⭐⭐⭐

适合战队的原因：
1. **学习曲线适中**：新成员只需理解自己负责的模块
2. **调试友好**：底盘和机械臂问题独立，不互相干扰
3. **代码复用**：底层插补算法只需实现一次
4. **扩展预留**：明年增加云台/腿足时直接加模块

潜在问题：
- 接口设计需要一次性做好（否则后期修改困难）
- 需要一定的架构设计能力

**方案二（策略）- 不推荐** ⭐⭐⭐

不适合战队的原因：
1. **过度设计**：战队很少需要运行时切换策略
2. **调试困难**：回调链出问题难以定位
3. **学习成本高**：新成员难以理解策略模式
4. **性能损耗**：函数指针调用在STM32上不必要

唯一适用场景：
- 需要做一个通用库供多个项目使用

**方案三（独立）- 备选** ⭐⭐⭐⭐

适合战队的原因：
1. **简单粗暴**：复制粘贴就能用
2. **零学习成本**：看到文件名就知道功能
3. **调试最快**：问题在哪一眼看到

潜在问题：
1. **代码重复**：插补算法要写多份
2. **维护噩梦**：发现一个bug要改三处
3. **技术债务**：一年后代码难以维护

---

## 5. 我的推荐意见

### 5.1 首选方案：方案四（枚举驱动配置）⭐⭐⭐⭐⭐

**理由**：

1. **最佳平衡点**
   - ✅ 调用简单（类似方案三的简洁）
   - ✅ 无全局变量（支持多实例）
   - ✅ 代码复用（共享插补算法）
   - ✅ 不需要写回调（配置枚举即可）

2. **彻底改进原设计**
   - 改进 `chassis_calculations.c` 的**全局变量**问题
   - 保留枚举的**调用便利性**
   - 去除回调注册的**复杂度**

3. **人员友好**
   - 新成员只需理解：配置结构体 + 两个函数调用
   - 枚举命名清晰，一眼看懂用途
   - 预定义模板支持一键配置

4. **调试友好**
   - switch-case 分发逻辑清晰
   - 没有函数指针，调用栈直观
   - 状态隔离，多实例不干扰

5. **长期维护**
   - 插补算法一处修改全局生效
   - 增加新场景只需添加适配器
   - 枚举扩展简单（添加枚举值+switch-case分支）

**对比原chassis_calculations.c的显著改进**：
| 改进点 | 原设计 | 方案四 |
|-------|--------|--------|
| 全局变量 | ❌ `chassis_speed_plan_type` 全局 | ✅ 每个规划器独立 |
| 多实例 | ❌ 不支持多底盘 | ✅ 支持多个 `UnifiedPlanner` |
| 状态隔离 | ❌ 静态全局状态 | ✅ `private_data` 隔离 |
| 扩展性 | ❌ 增加场景需改多处 | ✅ 增加适配器即可 |

### 5.2 次选方案：方案一（分层模块化）⭐⭐⭐⭐

**适用情况**：
- 如果明确需要**职责完全分离**（机械臂组和底盘组完全不重叠）
- 如果有充足时间设计**通用接口**
- 如果计划长期维护（3年以上）

**对比方案四**：
- ✅ 更清晰的职责分离
- ⚠️ 接口设计需要一次性做好
- ⚠️ 代码量稍多

### 5.3 备选方案：方案三（独立模块）⭐⭐⭐

**适用情况**：
- 如果今年比赛时间**极其紧张**（<2天）
- 如果**无法接受任何重构风险**
- 如果当前代码已经"能用"且不想改

**风险**：
- 技术债务累积
- bug修复工作量大
- 明年需重构

### 5.4 不推荐方案二（策略模式）⭐⭐

**原因**：
- 在战队场景下是**过度设计**
- 需要写回调函数，增加使用负担
- 函数指针开销不必要
- 灵活性战队用不上

---

## 6. 具体实施建议

### 6.1 如果选择方案四（推荐）⭐⭐⭐⭐⭐

**第一阶段：框架搭建（1天）**
1. 创建 `planner_types.h`（枚举定义）
2. 创建 `unified_planner.h`（API接口）
3. 保留TD模块不变
4. 设计 `UnifiedPlanner` 结构体

**第二阶段：插补与约束（1-2天）**
1. 实现 `interpolation.c`（梯形、余弦、S曲线）
2. 实现 `constraint.c`（速度向量限幅、关节限幅）
3. 单元测试插补算法

**第三阶段：适配器实现（1-2天）**
1. 实现 `chassis_adapter.c`（底盘适配器）
   - 包含 `speed_point_limit` 逻辑
   - 包含余弦平滑调用
2. 实现 `joint_adapter.c`（机械臂适配器）
3. 实现预定义配置模板

**第四阶段：集成测试（1天）**
1. 底盘场景联调
2. 机械臂场景联调
3. 边界条件测试

**预计总工时**：4-6天（2人并行）
**代码行数预计**：约600-800行（含注释）

**快速迁移路径**（从现有代码）：
- 直接复制 `cosine_update_speed` 到 `interp_cosine()`
- 直接复制 `speed_point_limit` 到 `constraint_speed_vector()`
- 修改 `chassis_calculations` 的 switch-case 为 `planner_update()` 分发

### 6.2 如果选择方案一（分层模块化）

**第一阶段（1-2天）**：
1. 设计通用接口（`trajectory_base.h`）
2. 提取公共插补算法到 `interpolation.h/c`
3. 保留TD模块不变

**第二阶段（2-3天）**：
1. 重构 `trajectory_chassis`（使用余弦平滑）
2. 移除 `chassis_calculations` 中的死代码
3. 实现 `speed_point_limit` 在底盘模块内

**第三阶段（1-2天）**：
1. 为机械臂创建 `trajectory_joint` 模块
2. 从现有代码迁移关节规划逻辑
3. 联调测试

**预计总工时**：5-7天（2人并行）

### 6.3 如果选择方案三（独立模块）

**实施步骤（1-2天）**：
1. 保留TD模块
2. 保留 `trajectory_plan` 作为机械臂用
3. 重写 `chassis_calculations`，删除死代码
4. 添加余弦平滑到底盘模块

**风险**：
- 插补算法重复实现
- 后期维护困难

---

## 7. 需要讨论的问题

1. **人员安排**
   - 今年有多少时间可以用于架构重构？
   - 谁负责机械臂部分？谁负责底盘部分？

2. **技术储备**
   - 团队成员对分层架构的理解程度？
   - 是否需要先做培训？

3. **测试资源**
   - 是否有足够的时间进行模块测试？
   - 是否有测试框架支持？

4. **历史代码**
   - `chassis_calculations` 中的有效代码有哪些必须保留？
   - `trajectory_plan` 是否有未提交的新功能？

5. **方案四特定问题（枚举驱动）**
   - 预定义配置模板需要几种？（底盘余弦、底盘梯形、机械臂S曲线？）
   - 是否需要支持运行时切换插补模式？（初始化后是否允许从梯形切到余弦？）
   - union内存使用是否可接受？（需要类型安全检查）
   - TD是否必须集成到规划器内？（当前设计是可选的 `use_td` 标志）

6. **方案对比**
   - 学长的回调注册方案已经写了多少代码？（评估迁移成本）
   - 如果已有大量回调注册代码，是否值得改为枚举方案？
   - 团队对enum的接受度如何？

---

## 8. 附录：当前代码保留清单

### 8.1 确定保留的代码

**TD模块** (`td/`)：
- ✅ `td.h` / `td.c` - 完整保留（已提取）
- 约130行，结构清晰，API友好

**轨迹规划** (`trajectory_plan/`)：
- ✅ `t_trajectory_init` - 完整保留
- ✅ `t_trajectory_update` - 完整保留（三阶段状态机）
- ✅ `TrajectoryState` 枚举
- ✅ `Trajectory_Handler_t` 结构体
- ❌ `#define PI` - 删除（使用标准库）
- ❌ `s_trajectory_update` - 删除（未实现）

### 8.2 待评估的代码

**底盘模块** (`chassis_calculations/`)：
- ⚠️ `cosine_update_speed` - 保留算法（约10行）
- ⚠️ `speed_point_limit` - 保留逻辑（约30行）
- ❌ 所有 `#if 0` 代码块 - 删除（约250行）
- ❌ `scurve_update_speed` - 删除（TODO占位）

**余弦平滑算法**（来自 `chassis_calculations.c:79-87`）：
```c
// 保留这段算法，可放入公共插补库
static void cosine_update_speed(float diff, float max_change, 
                               float* current_speed, float target_speed) {
    if (my_fabs(diff) > 0.001f && my_fabs(diff) > max_change) {
        float ratio = max_change / my_fabs(diff);
        float smooth_factor = 0.5f * (1.0f - cosf(PI * ratio));
        *current_speed = *current_speed + diff * smooth_factor;
    } else {
        *current_speed = target_speed;
    }
}
```

---

**文档生成时间**：2026-02-09  
**作者**：opencode AI  
**版本**：1.0  
**目的**：供战队技术讨论使用
