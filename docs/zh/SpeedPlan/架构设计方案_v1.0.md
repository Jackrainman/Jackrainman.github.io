# 轨迹规划与速度控制模块架构设计方案

## 1. 项目背景与需求

### 1.1 当前代码现状
经过对 `trajectory_plan`、`ladrc`（已提取TD）、`chassis_calculations` 三个模块的详细分析，发现以下问题：

- **代码冗余**：chassis_calculations 模块包含约 250 行死代码（`#if 0` 块）
- **功能未实现**：S型速度规划仅定义接口，内部是TODO占位符
- **架构混乱**：全局变量滥用，命名混乱，场景混合

### 1.2 使用场景需求

| 场景类型 | 核心需求 | 约束特点 | 典型算法 |
|---------|---------|---------|---------|
| **机械臂关节规划** | 各关节独立运动 | 关节位置/速度/加速度限制 | 梯形/S曲线插补 |
| **机械臂笛卡尔规划** | 末端位姿平滑 | 笛卡尔速度/加速度限制 | 冗余度解析、阻尼最小二乘 |
| **底盘速度向量限制** | 速度幅值约束（防侧翻） | 速度向量模长限制 | 速度幅值限制、向量归一化、余弦平滑 |

### 1.3 关键约束差异

**机械臂场景**：
- 关心每个关节的运动学限制
- 需要反向运动学计算
- 末端位姿精度要求高

**底盘场景**：
- 关心速度向量的幅值（`speed_point_limit` 防侧翻）
- 需要实时平滑（从A点到B点，保持`last_point`记忆）
- 快速响应，避免机械冲击

---

## 2. 三种架构方案详细设计

---

### 方案一：分层模块化（推荐架构）

#### 2.1 架构图示

```
┌─────────────────────────────────────────────────────────────┐
│                    Trajectory_Plan_API                       │
│        init() / update() / get_state() / reset()             │
└───────────────────────────┬─────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│  JointPlan    │   │ CartesianPlan │   │  ChassisPlan  │
│ (机械臂关节)   │   │ (机械臂笛卡尔) │   │   (底盘)      │
├───────────────┤   ├───────────────┤   ├───────────────┤
│ 梯形/S曲线插补  │   │  速度投影+逆解 │   │ 速度向量限幅   │
│ 关节独立限幅    │   │  笛卡尔速度限制 │   │ 防侧翻约束    │
└───────────────┘   └───────────────┘   └───────────────┘
                ┌───────────────────┐
                ▼                   ▼
        ┌───────────────┐   ┌───────────────┐
        │  通用插补库   │   │   约束检查库   │
        │ • 梯形        │   │ • 位置限幅    │
        │ • S曲线       │   │ • 速度限幅    │
        │ • 余弦        │   │ • 加速度限幅  │
        └───────────────┘   └───────────────┘
```

#### 2.2 文件结构

```
trajectory_plan/
├── trajectory_base.h          # 通用API接口定义
│   ├── PlannerState 结构体
│   ├── PlannerType 枚举
│   ├── PlannerConfig 配置
│   └── 虚函数接口声明
├── trajectory_base.c          # 基础逻辑（可复用代码）
├── trajectory_joint.h/c       # 关节空间规划实现
├── trajectory_cartesian.h/c   # 笛卡尔空间规划实现
└── trajectory_chassis.h/c     # 底盘专用规划
    └── 包含 speed_point_limit 逻辑

utils/
├── interpolation.h/c          # 插补算法库
│   ├── trapezoid_interp()     # 梯形插补
│   ├── scurve_interp()        # S曲线插补
│   └── cosine_interp()        # 余弦平滑
└── constraint.h/c             # 约束检查工具
    ├── check_joint_limit()
    └── check_speed_vector()
```

#### 2.3 代码示例

```c
// trajectory_base.h

typedef enum {
    PLANNER_TRAPEZOID,   // 梯形规划
    PLANNER_SCURVE,      // S曲线规划
    PLANNER_COSINE,      // 余弦规划
} InterpolationType;

typedef struct {
    float p_start;
    float p_goal;
    float v_max;
    float a_max;
    float dt;
} PlannerConfig;

typedef struct {
    float current_p;     // 当前位置
    float current_v;     // 当前速度
    float current_a;     // 当前加速度
    int   finished;      // 是否完成
} PlannerState;

// 虚接口
void planner_init(void* instance, PlannerConfig* cfg);
int  planner_update(void* instance, float target, float measure, PlannerState* out);
void planner_reset(void* instance, float init_val);

// trajectory_chassis.h
// 底盘特有配置
typedef struct {
    PlannerConfig base;
    
    // 底盘特有
    float last_vx;       // 上周期X速度
    float last_vy;       // 上周期Y速度
    float speed_limit;   // 速度限制阈值
    float base_limit;    // 基础速度限制
    float max_limit;     // 最大速度限制
} ChassisConfig;

// 底盘特有状态
typedef struct {
    PlannerState vx_state;
    PlannerState vy_state;
    PlannerState vw_state;
} ChassisState;

void chassis_planner_init(ChassisConfig* cfg);
void chassis_planner_update(float target_vx, float target_vy, float target_vw,
                           ChassisState* state);
```

#### 2.4 优缺点分析

**优点**：
- ✅ **职责分离**：每个模块只负责自己的场景
- ✅ **易于扩展**：增加云台/腿足等新场景只需添加新模块
- ✅ **代码复用**：插补算法在底层统一实现
- ✅ **调试方便**：底盘和机械臂问题独立排查

**缺点**：
- ⚠️ **代码量中等**：比完全独立方案多一些接口代码
- ⚠️ **需要学习成本**：需要理解分层架构

---

### 方案二：策略模式 + 回调注册

#### 2.1 架构图示

```
┌─────────────────────────────────────────────────────────────┐
│              TrajectoryPlanner（统一入口）                    │
│  ┌─────────────────────────────────────────────────────┐  │
│  │  配置结构体:                                          │  │
│  │    - interpolation_type: TRAPEZOID/SCURVE/COSINE     │  │
│  │    - constraint_type: JOINT_LIMIT / CARTESIAN_LIMIT  │  │
│  │                        / CHASSIS_SPEED_LIMIT         │  │
│  │    - constraint_fn: 用户自定义约束回调                │  │
│  └─────────────────────────────────────────────────────┘  │
└───────────────────────────┬─────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ 插补策略      │   │ 约束策略      │   │ 回调函数      │
├───────────────┤   ├───────────────┤   ├───────────────┤
│ • 梯形        │   │ • 关节限幅    │   │ 用户自定义    │
│ • S曲线       │   │ • 笛卡尔限幅  │   │               │
│ • 余弦        │   │ • 底盘限幅    │   │               │
└───────────────┘   └───────────────┘   └───────────────┘
```

#### 2.2 文件结构

```
trajectory_plan/
├── trajectory_planner.h/c     # 核心规划器（策略控制器）
├── trajectory_config.h        # 统一配置
├── strategy/
│   ├── interpolation.h/c      # 插补策略
│   │   ├── strategy_trapezoid()
│   │   ├── strategy_scurve()
│   │   └── strategy_cosine()
│   └── constraint.h/c         # 约束策略
│       ├── constraint_joint()
│       ├── constraint_cartesian()
│       └── constraint_chassis()  // 包含防侧翻逻辑
└── callback.h                 # 回调定义

// 使用示例
PlannerConfig cfg = {
    .interp_type = PLANNER_COSINE,
    .constraint_type = CONSTRAINT_CHASSIS,
    .custom_constraint = my_extra_constraint,
};
planner_init(&planner, &cfg);
```

#### 2.3 代码示例

```c
// trajectory_planner.h

typedef enum {
    INTERP_TRAPEZOID,
    INTERP_SCURVE,
    INTERP_COSINE,
} InterpolationStrategy;

typedef enum {
    CONSTRAINT_NONE,
    CONSTRAINT_JOINT,      // 机械臂关节约束
    CONSTRAINT_CARTESIAN,  // 笛卡尔空间约束
    CONSTRAINT_CHASSIS,    // 底盘速度向量约束
} ConstraintStrategy;

// 约束回调签名
typedef void (*ConstraintCallback)(float* target_vx, float* target_vy,
                                   float* target_vw, void* user_data);

typedef struct {
    InterpolationStrategy interp_type;
    ConstraintStrategy constraint_type;
    ConstraintCallback custom_constraint;  // 可选
    void* user_data;
    
    // 物理参数
    float max_accel;
    float max_decel;
    float dt;
} PlannerConfig;

typedef struct {
    PlannerConfig cfg;
    
    // 状态
    float current_speed;
    float current_accel;
    
    // 插补状态（根据策略不同而不同）
    void* interp_state;
} TrajectoryPlanner;

void planner_init(TrajectoryPlanner* planner, PlannerConfig* cfg);
int planner_update(TrajectoryPlanner* planner,
                  float target, float measure,
                  float* output_speed);

// 约束策略实现示例
void constraint_chassis(float* vx, float* vy, float* vw, void* data) {
    ChassisConstraintData* d = (ChassisConstraintData*)data;
    
    // 计算速度变化量
    float dx = *vx - d->last_vx;
    float dy = *vy - d->last_vy;
    float distance = sqrt(dx*dx + dy*dy);
    
    // 根据梯形函数计算速度限制
    float limit;
    if (distance <= d->threshold) {
        limit = d->threshold;
    } else if (distance <= d->threshold + (d->max_limit - d->base_limit) * 2.0f) {
        limit = d->base_limit + (distance - d->threshold) / 2.0f;
    } else {
        limit = d->max_limit;
    }
    
    // 限幅
    if (distance > limit) {
        float ratio = limit / distance;
        *vx = d->last_vx + dx * ratio;
        *vy = d->last_vy + dy * ratio;
    }
    
    // 更新历史
    d->last_vx = *vx;
    d->last_vy = *vy;
}
```

#### 2.4 优缺点分析

**优点**：
- ✅ **灵活性最高**：可随时切换插补和约束策略
- ✅ **配置驱动**：通过配置表即可改变行为
- ✅ **扩展性强**：新增策略只需注册新函数
- ✅ **适合通用库**：可作为战队通用底层库

**缺点**：
- ⚠️ **实现复杂度高**：需要理解策略模式和回调机制
- ⚠️ **运行时开销**：函数指针调用有微小开销
- ⚠️ **调试困难**：策略动态组合时问题定位难
- ⚠️ **学习曲线陡峭**：对新成员不友好

---

### 方案三：完全独立模块（最简单）

#### 2.1 架构图示

```
┌─────────────────────────────────────────────────────────────┐
│                      完全独立，零耦合                        │
└─────────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ joint_planner │   │cartesian_planner│  │chassis_limiter│
│  (机械臂关节)  │   │ (机械臂笛卡尔)  │   │   (底盘)      │
├───────────────┤   ├───────────────┤   ├───────────────┤
│ 梯形规划      │   │ 位姿规划      │   │ 速度向量限幅   │
│ 关节限幅      │   │ 逆运动学      │   │ 防侧翻检查    │
└───────────────┘   └───────────────┘   └───────────────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            ▼
                  ┌───────────────┐
                  │  td/ (TD模块) │  // 仅引用TD
                  │  微分平滑     │
                  └───────────────┘
```

#### 2.2 文件结构

```
modules/
├── joint_planner/
│   ├── joint_planner.h/c      # 机械臂关节规划
│   └── 完全独立实现
├── cartesian_planner/
│   ├── cartesian_planner.h/c  # 笛卡尔规划
│   └── 完全独立实现
├── chassis_planner/
│   ├── chassis_planner.h/c    # 底盘规划
│   └── speed_point_limit 实现
└── common/
    ├── interpolation.h/c      # 可选：公共插补（如果不复用可删除）
    └── math_utils.h/c         # 可选：数学工具

td/                          # TD模块（独立）
├── td.h
└── td.c
```

#### 2.3 代码示例

```c
// joint_planner.h - 机械臂关节专用
#ifndef JOINT_PLANNER_H
#define JOINT_PLANNER_H

typedef struct {
    float q_start[6];     // 起始关节角度
    float q_goal[6];      // 目标关节角度
    float v_max[6];       // 各关节最大速度
    float a_max[6];       // 各关节最大加速度
    float dt;             // 控制周期
} JointPlanConfig;

typedef struct {
    float q_current[6];
    float v_current[6];
    int finished;
} JointPlanState;

void joint_planner_init(JointPlanConfig* cfg);
int joint_planner_update(float target[6], JointPlanState* state);

#endif

// chassis_planner.h - 底盘专用
#ifndef CHASSIS_PLANNER_H
#define CHASSIS_PLANNER_H

typedef struct {
    float max_accel_x;    // X方向最大加速度
    float max_accel_y;    // Y方向最大加速度
    float max_accel_w;    // 旋转最大角加速度
    float dt;             // 控制周期
    
    // 速度向量限制参数
    float base_limit;     // 基础速度限制
    float max_limit;      // 最大速度限制
    float threshold;      // 阈值速度
} ChassisPlanConfig;

typedef struct {
    float vx;             // 当前X速度
    float vy;             // 当前Y速度
    float vw;             // 当前角速度
    float last_vx;        // 上周期X速度
    float last_vy;        // 上周期Y速度
} ChassisPlanState;

void chassis_planner_init(ChassisPlanConfig* cfg);
void chassis_planner_update(float target_vx, float target_vy, float target_vw,
                           ChassisPlanState* state);

// 余弦平滑算法
void cosine_smooth(float diff, float max_change, float* current, float target);

// 速度向量限制（防侧翻核心）
void speed_point_limit(float* vx, float* vy, 
                       float last_vx, float last_vy,
                       float base_limit, float max_limit, float threshold);

#endif
```

#### 2.4 优缺点分析

**优点**：
- ✅ **实现最简单**：直接复制现有代码即可
- ✅ **零学习成本**：看到文件名就知道功能
- ✅ **调试方便**：问题就在对应模块里
- ✅ **无耦合风险**：修改一个不影响其他

**缺点**：
- ❌ **代码重复**：插补算法要写三份（如果有差异）
- ❌ **维护困难**：修复一个bug要在多处修改
- ❌ **无抽象层次**：难以看出架构设计
- ❌ **难以扩展**：增加新场景=增加新文件

---

## 3. 方案对比总表

| 维度 | 方案一（分层） | 方案二（策略） | 方案三（独立） |
|-----|--------------|--------------|--------------|
| **实现复杂度** | 中 | 高 | 低 |
| **代码复用性** | 高 | 极高 | 低 |
| **扩展性** | 好 | 极好 | 差 |
| **运行时性能** | 高 | 中（函数指针开销） | 高 |
| **调试难度** | 中 | 高 | 低 |
| **新成员友好度** | 中 | 低 | 高 |
| **长期维护性** | 好 | 好 | 差 |

### 3.1 关键能力对比

| 能力 | 方案一 | 方案二 | 方案三 |
|-----|--------|--------|--------|
| **机械臂关节规划** | ✅ 专用模块 | ✅ 策略配置 | ✅ 独立文件 |
| **机械臂笛卡尔规划** | ✅ 专用模块 | ✅ 策略配置 | ✅ 独立文件 |
| **底盘速度向量限制** | ✅ 专用模块 | ✅ 策略配置 | ✅ 独立文件 |
| **余弦速度曲线** | ✅ 通用插补 | ✅ 可插拔策略 | ✅ 独立实现 |
| **运行时切换策略** | ❌ 需重新初始化 | ✅ 支持 | ❌ 不支持 |
| **自定义约束** | ⚠️ 需修改代码 | ✅ 回调注册 | ⚠️ 需修改代码 |

---

## 4. 针对战队场景的深入分析

### 4.1 战队技术背景考量

**人员构成**：
- 每年人员流动大（学长毕业、学弟加入）
- 部分成员嵌入式经验有限
- 需要快速上手和调试

**开发周期**：
- 比赛周期紧张，没有太多时间重构
- 需要稳定可靠的基础代码
- 调试时间多于开发时间

**使用场景**：
- 机械臂和底盘通常不会同时大幅修改
- 插补算法相对固定（梯形为主，偶尔S曲线）
- 约束场景明确（不会出现奇怪的组合需求）

### 4.2 各方案在战队场景的表现

**方案一（分层）- 推荐** ⭐⭐⭐⭐⭐

适合战队的原因：
1. **学习曲线适中**：新成员只需理解自己负责的模块
2. **调试友好**：底盘和机械臂问题独立，不互相干扰
3. **代码复用**：底层插补算法只需实现一次
4. **扩展预留**：明年增加云台/腿足时直接加模块

潜在问题：
- 接口设计需要一次性做好（否则后期修改困难）
- 需要一定的架构设计能力

**方案二（策略）- 不推荐** ⭐⭐⭐

不适合战队的原因：
1. **过度设计**：战队很少需要运行时切换策略
2. **调试困难**：回调链出问题难以定位
3. **学习成本高**：新成员难以理解策略模式
4. **性能损耗**：函数指针调用在STM32上不必要

唯一适用场景：
- 需要做一个通用库供多个项目使用

**方案三（独立）- 备选** ⭐⭐⭐⭐

适合战队的原因：
1. **简单粗暴**：复制粘贴就能用
2. **零学习成本**：看到文件名就知道功能
3. **调试最快**：问题在哪一眼看到

潜在问题：
1. **代码重复**：插补算法要写多份
2. **维护噩梦**：发现一个bug要改三处
3. **技术债务**：一年后代码难以维护

---

## 5. 我的推荐意见

### 5.1 首选方案：方案一（分层模块化）

**理由**：

1. **技术债务最少**
   - 代码复用性高，避免重复实现
   - 架构清晰，后期维护成本低
   - 适合战队的长期发展

2. **人员友好**
   - 机械臂组只看 `trajectory_joint`
   - 底盘组只看 `trajectory_chassis`
   - 两组并行开发不冲突

3. **扩展性强**
   - 明年增加云台：直接加 `trajectory_gimbal`
   - 插补算法升级：改一处全局生效
   - 新增约束：在对应模块独立添加

4. **调试效率**
   - 问题分层隔离
   - 单元测试方便
   - 日志和调试信息可独立配置

### 5.2 备选方案：方案三（独立模块）

**适用情况**：
- 如果今年比赛时间非常紧张
- 如果架构重构风险太大
- 如果当前代码已经"能用"

**风险**：
- 明年将面对大量重复代码
- bug修复工作量大
- 新成员学习成本高（需要理解多份代码）

### 5.3 不推荐方案二（策略模式）

**原因**：
- 在战队场景下是过度设计
- 增加的灵活性战队用不上
- 提高了代码复杂度但没有实际收益

---

## 6. 具体实施建议

### 6.1 如果选择方案一

**第一阶段（1-2天）**：
1. 设计通用接口（`trajectory_base.h`）
2. 提取公共插补算法到 `interpolation.h/c`
3. 保留TD模块不变

**第二阶段（2-3天）**：
1. 重构 `trajectory_chassis`（使用余弦平滑）
2. 移除 `chassis_calculations` 中的死代码
3. 实现 `speed_point_limit` 在底盘模块内

**第三阶段（1-2天）**：
1. 为机械臂创建 `trajectory_joint` 模块
2. 从现有代码迁移关节规划逻辑
3. 联调测试

**预计总工时**：5-7天（2人并行）

### 6.2 如果选择方案三

**实施步骤（1-2天）**：
1. 保留TD模块
2. 保留 `trajectory_plan` 作为机械臂用
3. 重写 `chassis_calculations`，删除死代码
4. 添加余弦平滑到底盘模块

**风险**：
- 插补算法重复实现
- 后期维护困难

---

## 7. 需要讨论的问题

1. **人员安排**
   - 今年有多少时间可以用于架构重构？
   - 谁负责机械臂部分？谁负责底盘部分？

2. **技术储备**
   - 团队成员对分层架构的理解程度？
   - 是否需要先做培训？

3. **测试资源**
   - 是否有足够的时间进行模块测试？
   - 是否有测试框架支持？

4. **历史代码**
   - `chassis_calculations` 中的有效代码有哪些必须保留？
   - `trajectory_plan` 是否有未提交的新功能？

5. **接口设计**
   - 是否需要支持运行时切换规划模式？
   - 是否需要支持在线调参？

---

## 8. 附录：当前代码保留清单

### 8.1 确定保留的代码

**TD模块** (`td/`)：
- ✅ `td.h` / `td.c` - 完整保留（已提取）
- 约130行，结构清晰，API友好

**轨迹规划** (`trajectory_plan/`)：
- ✅ `t_trajectory_init` - 完整保留
- ✅ `t_trajectory_update` - 完整保留（三阶段状态机）
- ✅ `TrajectoryState` 枚举
- ✅ `Trajectory_Handler_t` 结构体
- ❌ `#define PI` - 删除（使用标准库）
- ❌ `s_trajectory_update` - 删除（未实现）

### 8.2 待评估的代码

**底盘模块** (`chassis_calculations/`)：
- ⚠️ `cosine_update_speed` - 保留算法（约10行）
- ⚠️ `speed_point_limit` - 保留逻辑（约30行）
- ❌ 所有 `#if 0` 代码块 - 删除（约250行）
- ❌ `scurve_update_speed` - 删除（TODO占位）

**余弦平滑算法**（来自 `chassis_calculations.c:79-87`）：
```c
// 保留这段算法，可放入公共插补库
static void cosine_update_speed(float diff, float max_change, 
                               float* current_speed, float target_speed) {
    if (my_fabs(diff) > 0.001f && my_fabs(diff) > max_change) {
        float ratio = max_change / my_fabs(diff);
        float smooth_factor = 0.5f * (1.0f - cosf(PI * ratio));
        *current_speed = *current_speed + diff * smooth_factor;
    } else {
        *current_speed = target_speed;
    }
}
```

---

**文档生成时间**：2026-02-09  
**作者**：opencode AI  
**版本**：1.0  
**目的**：供战队技术讨论使用
