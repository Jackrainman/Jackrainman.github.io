# 速度规划模块 - 代码文档

本文档介绍速度规划相关模块的代码结构、API接口和使用方法。

---

## 目录

1. [梯形速度规划](#梯形速度规划)
2. [余弦速度规划](#余弦速度规划)
3. [S形速度规划](#s形速度规划)
4. [微分追踪器](#微分追踪器)
5. [使用示例](#使用示例)

---

## 梯形速度规划

### 核心思想

梯形速度规划将运动过程分为三个阶段：加速段、匀速段、减速段。速度曲线呈现梯形形状。

### API接口

```python
class TrapezoidalProfile:
    def __init__(self, max_velocity: float, max_acceleration: float):
        """
        初始化梯形速度规划器

        Args:
            max_velocity: 最大速度 (m/s)
            max_acceleration: 最大加速度 (m/s²)
        """

    def calculate(self, target_position: float, current_position: float,
                  current_velocity: float, dt: float) -> float:
        """
        计算下一时刻的速度参考值

        Args:
            target_position: 目标位置
            current_position: 当前位置
            current_velocity: 当前速度
            dt: 时间间隔 (s)

        Returns:
            速度参考值
        """
```

### 使用示例

```python
# 创建速度规划器
profile = TrapezoidalProfile(max_velocity=2.0, max_acceleration=1.0)

# 主循环中调用
velocity_ref = profile.calculate(target_pos, current_pos, current_vel, dt)
```

---

## 余弦速度规划

### 核心思想

余弦速度规划使用余弦函数生成平滑的速度曲线，避免速度突变，实现更柔和的运动。

### API接口

```python
class CosineProfile:
    def __init__(self, max_velocity: float, acceleration_time: float = 0.5):
        """
        初始化余弦速度规划器

        Args:
            max_velocity: 最大速度 (m/s)
            acceleration_time: 加速段时间 (s)
        """

    def calculate(self, target_position: float, current_position: float,
                  current_velocity: float, dt: float) -> float:
        """
        计算下一时刻的速度参考值
        """
```

### 使用示例

```python
# 创建余弦速度规划器
cos_profile = CosineProfile(max_velocity=1.5, acceleration_time=0.3)

# 主循环中调用
velocity_ref = cos_profile.calculate(target_pos, current_pos, current_vel, dt)
```

---

## S形速度规划

*（该部分代码尚未实现，学弟/学妹可在此处补充）*

### 计划接口

```python
class SigmoidProfile:
    def __init__(self, max_velocity: float, max_acceleration: float, jerk_limit: float):
        """
        初始化S形速度规划器

        Args:
            max_velocity: 最大速度 (m/s)
            max_acceleration: 最大加速度 (m/s²)
            jerk_limit: 最大加加速度 (m/s³)
        """

    def calculate(self, target_position: float, current_position: float,
                  current_velocity: float, dt: float) -> float:
        """
        计算下一时刻的速度参考值
        """
```

---

## 微分追踪器

### 核心思想

微分追踪器是一种自抗扰控制（ADRC）中的核心组件，其设计目标是：
- **大误差时**：快速响应，"油门焊死"追踪目标
- **接近目标时**：平滑过渡到PD控制，避免超调和震荡

### 理论简述

微分追踪器通过安排过渡过程（Transition Process），使输入信号缓慢过渡，避免突变。其核心公式：

$$u = fhan(e, \dot{e}, r, h)$$

其中：
- $e$：误差（目标值 - 实际值）
- $\dot{e}$：误差微分
- $r$：跟踪速度因子
- $h$：滤波因子

### API接口

```python
class Differentiator:
    def __init__(self, r: float = 1e6, h: float = 0.01, h0: float = 0.01):
        """
        初始化微分追踪器

        Args:
            r: 跟踪速度因子，越大响应越快
            h: 滤波因子，越大滤波效果越好但响应越慢
            h0: 初始滤波因子
        """

    def calculate(self, target: float, measurement: float, dt: float) -> tuple:
        """
        计算目标值的微分估计

        Args:
            target: 目标值
            measurement: 当前测量值
            dt: 时间间隔 (s)

        Returns:
            tuple: (微分估计, 目标值的估计)
        """
```

### 调参指南

| 参数 | 作用 | 调参建议 |
|------|------|----------|
| `r` | 跟踪速度因子 | 增大提高响应速度，过大可能震荡 |
| `h` | 滤波因子 | 增大增强滤波效果，但增加延迟 |
| `h0` | 初始滤波因子 | 通常设为与`h`相同 |

### 参数整定步骤

1. **初值设定**：设 `r = 1e6`, `h = 0.01`
2. **响应测试**：观察系统响应速度和超调情况
3. **调整 `r`**：如响应太慢，适当增大 `r`
4. **调整 `h`**：如噪声过大，适当增大 `h`

### 使用示例

```python
# 创建微分追踪器
diff_tracker = Differentiator(r=1e6, h=0.01)

# 主循环中调用
v_estimate, x_estimate = diff_tracker.calculate(target_vel, current_vel, dt)

# 使用微分估计值
control_output = kp * (x_estimate - current_pos) + kd * v_estimate
```

### 实际应用示例

```python
class VelocityController:
    def __init__(self):
        self.diff_tracker = Differentiator(r=5e5, h=0.005)
        self.kp = 0.5
        self.kd = 0.1

    def compute(self, target_velocity: float, current_velocity: float,
                current_position: float, dt: float) -> float:
        # 使用微分追踪器获取平滑的速度估计
        vel_diff, vel_estimate = self.diff_tracker.calculate(
            target_velocity, current_velocity, dt
        )

        # 计算控制输出
        output = self.kp * (vel_estimate - current_velocity) + self.kd * vel_diff

        return output
```

---

## 使用示例

### 速度规划器对比

```python
import numpy as np
import matplotlib.pyplot as plt

# 初始化三种速度规划器
trapezoid = TrapezoidalProfile(max_velocity=2.0, max_acceleration=1.0)
cosine = CosineProfile(max_velocity=2.0, acceleration_time=0.5)

# 模拟运动过程
target = 10.0
current = 0.0
velocity = 0.0
dt = 0.01

t_values = []
v_trapezoid = []
v_cosine = []

for i in range(1000):
    t = i * dt
    t_values.append(t)

    # 计算各规划器的速度
    v_t = trapezoid.calculate(target, current, velocity, dt)
    v_c = cosine.calculate(target, current, velocity, dt)

    v_trapezoid.append(v_t)
    v_cosine.append(v_c)

    # 更新位置
    current += velocity * dt
    velocity = v_t

# 绘制速度曲线
plt.figure(figsize=(10, 6))
plt.plot(t_values, v_trapezoid, label='Trapezoidal')
plt.plot(t_values, v_cosine, label='Cosine')
plt.xlabel('Time (s)')
plt.ylabel('Velocity (m/s)')
plt.legend()
plt.grid(True)
plt.savefig('velocity_profiles.png')
```

### 微分追踪器应用

```python
# 创建微分追踪器用于平滑速度指令
diff = Differentiator(r=1e6, h=0.01)

# 模拟速度指令平滑
target_vel = 5.0
noisy_vel = target_vel + np.random.normal(0, 0.1, 1000)

smoothed_vel, vel_rate = diff.calculate(target_vel, noisy_vel, 0.01)
```

---

## 注意事项

1. **时间间隔 `dt`**：必须使用准确的采样周期，建议使用硬件定时器获取
2. **参数整定**：微分追踪器的参数需要根据实际系统特性调整
3. **数值稳定性**：避免 `dt` 过小导致数值计算误差累积
4. **初始化**：首次调用前确保追踪器已正确初始化

---

## 常见问题

### Q1: 梯形规划器在短距离时无法达到最大速度？

这是正常现象。当目标距离太短时，系统会在加速后立即减速，无法进入匀速段。

### Q2: 微分追踪器输出震荡怎么办？

尝试减小 `r` 或增大 `h`，直到系统稳定。

### Q3: 余弦规划和S形规划如何选择？

余弦规划实现简单，适合对平滑性要求不高的场景；S形规划 jerk 受限，适合对机械冲击敏感的系统。

---

*文档版本：v1.0*
*最后更新：2024-XX-XX*
